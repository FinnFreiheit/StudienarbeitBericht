%!TEX root = ../../main.tex

\chapter{Progressive Web App}

Wie in Kapitel \ref{se:Begriffsklaerung} erwähnt verfügt eine PWA unter anderem über folgende Funktionen: 
\begin{itemize}
    \item Installierbar,
    \item zugriff auf Geräteschnittstellen, 
    \item Netzwerkunabhängig,
    \item Push-Notifikations.
\end{itemize} 

Im folgenden werden die theoretischen Grundlagen erläutert, die benötigt werden, um diese Funktionalitäten zu realisieren. 


\section{Web-App-Manifest}\label{sec:webappmanifest}

\begin{quote}
   \textit{The web app manifest is a JSON file that defines how the PWA should be treated as an installed application, including the look and feel and basic behavior within the operating system \cite{Developers2022}. }
\end{quote}

Eine PWA kann auf ein Endgerät wie zum Beispiel ein Desktop oder Handy installiert werden. Um diese Funktion zu realisieren, müssen zusätzliche Informationen wie zum Beispiel der Name und das Icon der installierten Applikation in einer Datei festgehalten werden. 

Bei dieser Datei handelt es sich um das sogenannte Web-App-Manifest. Die Informationen sind im \ac{JSON}-Format\footnote{durch Komma getrennte Schlüssel-Wert paare} angegeben. 

Ohne Das Manifest ist die Applikation nicht installierbar, somit ist die Datei eine zwingende Voraussetzung für eine PWA. 
Das Manifest muss mindestens ein \texttt{name}-Schlüssel und ein \texttt{String}-Wert aufweisen. 
Neben dem Namen der Applikation kann ein Manifest über folgende Informationen verfügen: 

\subsection{short\_name}
Unter \texttt{short\_name} kann ein kurzer Name der Applikation angegeben werden. Dieser Name wird verwendet, falls das Endgerät nicht über genügend platz verfügt, um den Originalen Namen anzuzeigen. 

\subsection{icons}
Unter \texttt{icons} wird ein Array\footnote{Datentyp, das mehrere Werte speichern kann} mit Bildobjekten gespeichert. Ein Bildobjekt besteht aus einem Dateipfad, unter dem das anzuzeigende Bild gespeichert ist, einer Typ Beschreibung des Bildes zum Beispiel \textit{png} oder \textit{svg}, eine Informationen über die Auflösung des Bildes und optional noch eine Angabe  welchem Zweck das Bild dient. 

Die Gespeicherten Bilder werden als App-Icon auf dem Desktop oder Handy angezeigt. 

\subsection{start\_url}
Die angegebene \texttt{start\_url} ist jene \ac{URL} die geöffnet wird, sobald der Nutzer das installierte Icon auswählt und somit die Applikation startet. 
Wird keine explizite Startadresse angegeben, so wird die URL verwendet, von der die PWA installiert wurde. 

\subsection{display}

Beim Auswählen des Installierten Icons wird die PWA in einem neuem Fenster geöffnet. Unter \texttt{display} kann angegeben werden, wie das Betriebssystem das Fenster darstellen soll. 
Es kann zwischen \texttt{Fullscreen}, \texttt{Standalone} und \texttt{Minimal User Interface} unterschieden werden. 
Der unterschied zwischen den einzelnen Auswahlmöglichkeiten liegt bei den Navigationselementen, siehe Abbildung \ref{img:Standalone} und \ref{img:minimalui}.

\begin{figure}[!htb]
    \includegraphics[scale=0.3]{Standalone.png}
    \caption{display in Standalone Einstellung}
    \label{img:Standalone}
\end{figure}

\begin{figure}
    \includegraphics[scale=0.3]{minimalui.png}
    \caption{display in Minimal User Interface Einstellung}
    \label{img:minimalui}
\end{figure}

\subsection{theme\_color}
Mit Hilfe dieser Einstellung kann die Farbe der oberen Navigationsleiste angepasst werden, wie in Abbildung \ref{img:themeColor} dargestellt ist. Hierbei ist jedoch darauf zu achten, das die Applikation nicht den meta tag theme-color definiert. 

\begin{figure}[!htb]
    \includegraphics[scale=0.3]{themeColor.png}
    \caption{Theme Color auf Weiß geändert}
    \label{img:themeColor}
\end{figure}

\subsection{Debugging vom Manifest}

Neben den oben aufgezählten Grundeinstellungen sind viele weitere Möglich. Um nachzuvollziehen, ob alle Einstellungen den Anforderungen entsprechen kann das Manifest mithilfe der Browser Entwicklerwerkzeuge untersucht werden. Unter Google Chrome kann unterm Reiter \textit{Application} das Manifest ausgewählt werden. Darauf hin erhält man folgende Ansicht, siehe Abbildung \ref{img:devManifest}.

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.3]{devToolsManifest.png}
    \caption{Entwicklereinstellungen Web-App-Manifest}
    \label{img:devManifest}
\end{figure}


\newpage

\section{Service Workers}\label{sec:ServiceWorker}
\begin{quote}
    \textit{Service workers are a fundamental part of a PWA. They enable fast loading (regardless of the network), offline access, push notifications, and other capabilities \cite{Developers2022a}.}
\end{quote}

Der \textit{Service Worker} ist ein wichtiger Grundbaustein um Funktionalitäten wie Push-Notifikations, Hintergrund-Synchronisation und die Möglichkeit, auch Offline die Anwendung auszuführen, zu realisieren. 

Bei dem \textit{Service Worker} handelt es sich um ein script das im Hintergrund des Browsers, unabhängig von der Webanwendung, läuft \cite{Gaunt2021}. Entstanden sind die service worker aus der Verwendung des Application Caches . Die service Worker \ac{API} wächst kontinuierlich und bietet zunehmende weitere Funktionalitäten.

Bei der Verwendung eines Service Worker sollten folgenden Eigenschaften berücksichtigt werden: 
\begin{itemize}
    \item Ein service worker kann zwar nicht direkt das \ac{DOM} einer Seite manipulieren, kann aber auf Requests der Seite mit Responses reagieren und die Seite selbst kann darufhin ihr DOM ändern
    \item Ein service worker ist ein \glqq programmierbarer\grqq{} Proxy, der steuert, wie Requests von der Webseite behandelt werden.
    \item Service workers verwenden die IndexDB API, um client-seitig strukturierte Daten persistent zu speichern.
    \item Service workers verwenden Promises. 
\end{itemize}

\subsection{Der Lebenszyklus eines Service Workers}

 
Der Service Worker wird vom Browser in einem eigenen Thread unabhängig der Applikation ausgeführt. Dementsprechend besitzt der Service Worker einen eigenen Lebenszyklus, der im folgenden genauer beschrieben wird. 

\subsubsection{Registrieren}
Der Lebenszyklus eines Service Workers beginnt mit der Registrierung. Dies erfolgt mithilfe der \texttt{register()} Methode in der \texttt{serviceWorker} Eigenschaft des \texttt{navigator}-Objektes \cite{Navigator2022}, siehe Listing \ref{lst:serviceWorker} Zeile 2. Um das Konzept von Progressive Enhancement zu folgen (Abschitt \ref{se:Begriffsklaerung}), sollte vor der Registrierung überprüft werden, ob die Service-Worker-Schnittstellen vorhanden sind. Hierfür wird die \texttt{serviceWorker} Eigenschaft im \texttt{navigator}-Objekt abgefragt, siehe Listing \ref{lst:serviceWorker} Zeile 1. 

\begin{lstlisting}[caption = Registrierung des Service Workers, label = lst:serviceWorker, float = !htb]
    if('serviceWorker' in navigator){
        navigator.serviceWorker.register('./sw.js')
        .then(registration => console.log(registration))
        .catch(error => console.error(error));
    }
\end{lstlisting}

Das Aufrufen der Methode \texttt{register()} gibt ein Promise zurück, welches in Zeile 3 und 4 behandelt wird. 
Im Erfolgsfall (then-Methode) wird ein Objekt von typ \texttt{ServiceWorkerRegistration} übergeben. Das Objekt verfügt unter anderem über folgende Schnittstellen: 
\begin{itemize}
    \item mit der \texttt{update()} Methode wird die Aktualisierung des Service Workers ausgelöst,
    \item die Methode \texttt{unregister()} hebt die Registrierung des Service Workers auf, welches im anschluss vom Browser gelöscht wird,
    \item die Eingenschaft \texttt{updatefound} wird aufgerufen, sobald der Browser eine neue Version des Service Workers gefunden hat. 
\end{itemize}

Bei der Registrierung wird das übergebene Script Zeile 2, vom Webbrowser abgerufen und geparst. 

\begin{figure}
    \centering
    \includegraphics[scale=0.45]{swonline.png}
    \caption{Laden einer Applikation ohne Service Worker}
    \label{img:swonline}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.45]{swoffline.png}
    \caption{Laden einer Applikation ohne Internetverbindung}
    \label{img:swoffline}
\end{figure}

\section{Progressive Web Apps in Angular}

Angular (Abschnitt \ref{Angular}) eignet sich sehr gut um eine PWA zu entwickeln, da beides Entwicklungen von Google sind. 
Um aus einer Angular Anwendung eine PWA zu erstellen, muss das Paket \texttt{@angular/pwa} über das \ac{CLI} hinzugefügt werden.
Durch das hinzufügen des Paketes werden im Hintergrund folgende Veränderungen an dem Projekt durchgeführt: 
\begin{itemize}
    \item Das Paket \texttt{@angular/service-worker} wird zum Projekt hinzugefügt,
    \item der Build Support für den Service Worker wird in der Angular CLI aktiviert,
    \item das \texttt{ServiceWorkerModule} wird im \texttt{AppModule} importiert,
    \item die Datei index.html wird um ein Link zum Web App Manifest (Abschitt \ref{sec:webappmanifest}) und um relevante Meta-Tags ergänzt,
    \item Icon-Dateien werden erzeugt und verlinkt,
    \item die Konfigurationsdatei \textit{ngsw-config.json} für den Service Worker wird erzeugt. 
\end{itemize}

Im anschluss kann die Applikation alle Grundfunktionen einer PWA ausführen. Die Anwendung kann installiert werden. Im Web App Manifest steht der Projektname und das unter \texttt{assets} abgespeicherte Angular Icon wird als App-Icon verwendet. Nach dem erstmaligen öffnen der Applikation im Browser wird der Service Worker Installiert. Anschließend kann die Webseite auch ohne Netzwerkverbindung geladen werden.  



\section{PWA für IOS}

Apple unterstützt die Entwicklung von PWAs nicht. PWAs stellen  eine Möglichkeit dar, um Apps für das IPhon zu Installieren, die sich nicht im App Store befinden. Im Jahr 2020 hat Apple mit dem App Store ein Umsatz von 643 Milliarden US-Doller erwirtschaftet \cite{Kirchenbauer2021}. Apple erhält 30\% Provision, wenn eine App gekauft oder wenn In-App Käufe abgeschlossen werden. Durch PWAs könnte diese Einnahmequelle wegfallen. 

Durch zusätzliche Einstellungen können PWAs auf dem Homescreen von IOS Geräten installiert werde. Im \texttt{head} der \texttt{index.html} muss der Dateipfad zum verwendeten Icon angegeben werden, da dieser Pfad nicht aus dem Web-App-Manifest ausgelesen wird. 
Des weiteren muss in einem \texttt{meta-tag} angegeben werden, das die Webanwendung als App genutzt werden kann. Diese zusätzlichen Angaben ermöglichen es die Applikation zu installieren, Apple beschränkt jedoch die volle Funktionsumfang der PWAs. Durch ein Softwareupdate hat Apple eine Zwangslöschung für lokal beschreibbare Speicherfunktionen eingeführt \cite{t3n2020}. Eine PWA nutzt diesen lokalen Speicher um Daten zu speichern. 
Auch der Service Worker wird von Safari nicht vollständig unterstützt. Safari ermöglicht weder Push-Nachrichten noch Hintergrund Synchronisation \cite{mediaevent}. 

\section{Push Notifikations}

Eine Notifikation ist eine Nachricht, die auf dem Endgerät des Nutzers Angezeigt wird. Dies kann als Reaktion auf eine Nutzereingabe geschehen, es kann jedoch auch unabhängig vom Nutzer eine Nachricht von einem Server \glqq gepusht\grqq{} werden und das auch ohne das die Applikation aktiv ist.  Um push Notifikations zu erzeugen werden zwei APIs benötigt. Die \textit{Notifikations API} visualisiert die Nachricht für den Nutzer und die \textit{Push API} erlaubt es den Service Worker, Kapitel \ref{sec:ServiceWorker}, Nachrichten zu verwalten, die vom Server gesendet wurden während die Applikation nicht aktiv war. 

\section{Endgerät Emulation }

Um eine PWA Lokal auf Endgeräten zu testen, können diese Emuliert werden.           
Um ein Android Handy zu Emuliere, kann das Programm \textit{Android Studio} verwendet werden. In Android Studio kann mithilfe des \ac{AVD Manager} ein Virtuelles Handy gestartet werden, Abbildung \ref{Android1} a. Im Emuliertem Handy kann der Browser geöffnet werden. Um auf die Lokale IP-Adresse des Rechners zugreifen zu können muss im Browser des Handys diese (\texttt{10.0.2.2:8080}) IP-Adresse eingegeben werden, Abbildung \ref{Android1} b. Daraufhin öffnet sich die Anwendung, die unter Einstellung installiert werden kann, Abbildung \ref{Android2} a. Die Anwendung wird darauf hin zum Startbildschirm hinzugefügt, Abbildung \ref{Android2} b.  

\begin{figure}[!htb]
    \centering
    \subfloat[][]{\includegraphics[scale=0.4]{emuliertHandy.png}}
    \qquad
    \subfloat[][]{\includegraphics[scale=0.4]{PWABrowser.png}}
    \caption{(a) Emuliertes Android Handy in Android Studio, (b) PWA im Browser geöffnet}
    \label{Android1}
\end{figure}

\begin{figure}[!htb]
    \centering
    \subfloat[][]{\includegraphics[scale=0.4]{InstallationPWA.png}}
    \qquad
    \subfloat[][]{\includegraphics[scale=0.4]{pwaInstalliert.png}}
    \caption{(a) Installation der PWA unter Android, (b) Installierte PWA }
    \label{Android2}
\end{figure}